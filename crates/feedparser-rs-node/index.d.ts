/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Content block */
export interface Content {
  /** Content body */
  value: string
  /** Content MIME type */
  type?: string
  /** Content language */
  language?: string
  /** Base URL for relative links */
  base?: string
}

/**
 * Detect feed format without full parsing
 *
 * # Arguments
 *
 * * `source` - Feed content as Buffer, string, or Uint8Array
 *
 * # Returns
 *
 * Feed version string (e.g., "rss20", "atom10")
 */
export declare function detectFormat(source: Buffer | string): string

/** Enclosure (attached media file) */
export interface Enclosure {
  /** Enclosure URL */
  url: string
  /** File size in bytes */
  length?: number
  /** MIME type */
  type?: string
}

/** Feed entry/item */
export interface Entry {
  /** Unique entry identifier */
  id?: string
  /** Entry title */
  title?: string
  /** Detailed title with metadata */
  titleDetail?: TextConstruct
  /** Primary link */
  link?: string
  /** All links associated with this entry */
  links: Array<Link>
  /** Short description/summary */
  summary?: string
  /** Detailed summary with metadata */
  summaryDetail?: TextConstruct
  /** Full content blocks */
  content: Array<Content>
  /** Publication date (milliseconds since epoch) */
  published?: number
  /** Last update date (milliseconds since epoch) */
  updated?: number
  /** Creation date (milliseconds since epoch) */
  created?: number
  /** Expiration date (milliseconds since epoch) */
  expired?: number
  /** Primary author name */
  author?: string
  /** Detailed author information */
  authorDetail?: Person
  /** All authors */
  authors: Array<Person>
  /** Contributors */
  contributors: Array<Person>
  /** Publisher name */
  publisher?: string
  /** Detailed publisher information */
  publisherDetail?: Person
  /** Tags/categories */
  tags: Array<Tag>
  /** Media enclosures (audio, video, etc.) */
  enclosures: Array<Enclosure>
  /** Comments URL or text */
  comments?: string
  /** Source feed reference */
  source?: Source
}

/** Feed metadata */
export interface FeedMeta {
  /** Feed title */
  title?: string
  /** Detailed title with metadata */
  titleDetail?: TextConstruct
  /** Primary feed link */
  link?: string
  /** All links associated with this feed */
  links: Array<Link>
  /** Feed subtitle/description */
  subtitle?: string
  /** Detailed subtitle with metadata */
  subtitleDetail?: TextConstruct
  /** Last update date (milliseconds since epoch) */
  updated?: number
  /** Primary author name */
  author?: string
  /** Detailed author information */
  authorDetail?: Person
  /** All authors */
  authors: Array<Person>
  /** Contributors */
  contributors: Array<Person>
  /** Publisher name */
  publisher?: string
  /** Detailed publisher information */
  publisherDetail?: Person
  /** Feed language (e.g., "en-us") */
  language?: string
  /** Copyright/rights statement */
  rights?: string
  /** Detailed rights with metadata */
  rightsDetail?: TextConstruct
  /** Generator name */
  generator?: string
  /** Detailed generator information */
  generatorDetail?: Generator
  /** Feed image */
  image?: Image
  /** Icon URL (small image) */
  icon?: string
  /** Logo URL (larger image) */
  logo?: string
  /** Feed-level tags/categories */
  tags: Array<Tag>
  /** Unique feed identifier */
  id?: string
  /** Time-to-live (update frequency hint) in minutes */
  ttl?: number
}

/** Generator metadata */
export interface Generator {
  /** Generator name */
  value: string
  /** Generator URI */
  uri?: string
  /** Generator version */
  version?: string
}

/** Image metadata */
export interface Image {
  /** Image URL */
  url: string
  /** Image title */
  title?: string
  /** Link associated with the image */
  link?: string
  /** Image width in pixels */
  width?: number
  /** Image height in pixels */
  height?: number
  /** Image description */
  description?: string
}

/** Link in feed or entry */
export interface Link {
  /** Link URL */
  href: string
  /** Link relationship type (e.g., "alternate", "enclosure", "self") */
  rel?: string
  /** MIME type of the linked resource */
  type?: string
  /** Human-readable link title */
  title?: string
  /** Length of the linked resource in bytes */
  length?: number
  /** Language of the linked resource */
  hreflang?: string
}

/**
 * Parse an RSS/Atom/JSON Feed from bytes or string
 *
 * # Arguments
 *
 * * `source` - Feed content as Buffer, string, or Uint8Array
 *
 * # Returns
 *
 * Parsed feed result with metadata and entries
 *
 * # Errors
 *
 * Returns error if input exceeds size limit or parsing fails catastrophically
 */
export declare function parse(source: Buffer | string): ParsedFeed

/**
 * Parsed feed result
 *
 * This is analogous to Python feedparser's `FeedParserDict`.
 */
export interface ParsedFeed {
  /** Feed metadata */
  feed: FeedMeta
  /** Feed entries/items */
  entries: Array<Entry>
  /** True if parsing encountered errors */
  bozo: boolean
  /** Description of parsing error (if bozo is true) */
  bozoException?: string
  /** Detected or declared encoding */
  encoding: string
  /** Detected feed format version */
  version: string
  /** XML namespaces (prefix -> URI) */
  namespaces: Record<string, string>
}

/**
 * Parse an RSS/Atom/JSON Feed with custom size limit
 *
 * # Arguments
 *
 * * `source` - Feed content as Buffer, string, or Uint8Array
 * * `max_size` - Optional maximum feed size in bytes (default: 100MB)
 *
 * # Returns
 *
 * Parsed feed result with metadata and entries
 *
 * # Errors
 *
 * Returns error if input exceeds size limit or parsing fails catastrophically
 */
export declare function parseWithOptions(source: Buffer | string, maxSize?: number | undefined | null): ParsedFeed

/** Person (author, contributor, etc.) */
export interface Person {
  /** Person's name */
  name?: string
  /** Person's email address */
  email?: string
  /** Person's URI/website */
  uri?: string
}

/** Source reference (for entries) */
export interface Source {
  /** Source title */
  title?: string
  /** Source link */
  link?: string
  /** Source ID */
  id?: string
}

/** Tag/category */
export interface Tag {
  /** Tag term/label */
  term: string
  /** Tag scheme/domain */
  scheme?: string
  /** Human-readable tag label */
  label?: string
}

/** Text construct with metadata */
export interface TextConstruct {
  /** Text content */
  value: string
  /** Content type ("text", "html", "xhtml") */
  type: string
  /** Content language */
  language?: string
  /** Base URL for relative links */
  base?: string
}
