/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Content block */
export interface Content {
  /** Content body */
  value: string
  /** Content MIME type */
  type?: string
  /** Content language */
  language?: string
  /** Base URL for relative links */
  base?: string
}

/**
 * Detect feed format without full parsing
 *
 * # Arguments
 *
 * * `source` - Feed content as Buffer, string, or Uint8Array
 *
 * # Returns
 *
 * Feed version string (e.g., "rss20", "atom10")
 */
export declare function detectFormat(source: Buffer | string): string

/** Enclosure (attached media file) */
export interface Enclosure {
  /** Enclosure URL */
  url: string
  /** File size in bytes */
  length?: number
  /** MIME type */
  type?: string
}

/** Feed entry/item */
export interface Entry {
  /** Unique entry identifier */
  id?: string
  /** Entry title */
  title?: string
  /** Detailed title with metadata */
  titleDetail?: TextConstruct
  /** Primary link */
  link?: string
  /** All links associated with this entry */
  links: Array<Link>
  /** Short description/summary */
  summary?: string
  /** Detailed summary with metadata */
  summaryDetail?: TextConstruct
  /** Full content blocks */
  content: Array<Content>
  /** Publication date (milliseconds since epoch) */
  published?: number
  /** Last update date (milliseconds since epoch) */
  updated?: number
  /** Creation date (milliseconds since epoch) */
  created?: number
  /** Expiration date (milliseconds since epoch) */
  expired?: number
  /** Primary author name */
  author?: string
  /** Detailed author information */
  authorDetail?: Person
  /** All authors */
  authors: Array<Person>
  /** Contributors */
  contributors: Array<Person>
  /** Publisher name */
  publisher?: string
  /** Detailed publisher information */
  publisherDetail?: Person
  /** Tags/categories */
  tags: Array<Tag>
  /** Media enclosures (audio, video, etc.) */
  enclosures: Array<Enclosure>
  /** Comments URL or text */
  comments?: string
  /** Source feed reference */
  source?: Source
  /** Podcast transcripts */
  podcastTranscripts: Array<PodcastTranscript>
  /** Podcast persons */
  podcastPersons: Array<PodcastPerson>
  /** License URL (Creative Commons, etc.) */
  license?: string
  /** Geographic location (GeoRSS) */
  geo?: GeoLocation
  /** Dublin Core creator (author) */
  dcCreator?: string
  /** Dublin Core date (milliseconds since epoch) */
  dcDate?: number
  /** Dublin Core subject tags */
  dcSubject: Array<string>
  /** Dublin Core rights (copyright) */
  dcRights?: string
  /** Media RSS thumbnails */
  mediaThumbnails: Array<MediaThumbnail>
  /** Media RSS content */
  mediaContent: Array<MediaContent>
  /** iTunes episode metadata */
  itunes?: ItunesEntryMeta
  /** Podcast 2.0 episode metadata */
  podcast?: PodcastEntryMeta
}

/** Feed metadata */
export interface FeedMeta {
  /** Feed title */
  title?: string
  /** Detailed title with metadata */
  titleDetail?: TextConstruct
  /** Primary feed link */
  link?: string
  /** All links associated with this feed */
  links: Array<Link>
  /** Feed subtitle/description */
  subtitle?: string
  /** Detailed subtitle with metadata */
  subtitleDetail?: TextConstruct
  /** Last update date (milliseconds since epoch) */
  updated?: number
  /** Initial publication date (milliseconds since epoch) */
  published?: number
  /** Primary author name */
  author?: string
  /** Detailed author information */
  authorDetail?: Person
  /** All authors */
  authors: Array<Person>
  /** Contributors */
  contributors: Array<Person>
  /** Publisher name */
  publisher?: string
  /** Detailed publisher information */
  publisherDetail?: Person
  /** Feed language (e.g., "en-us") */
  language?: string
  /** Copyright/rights statement */
  rights?: string
  /** Detailed rights with metadata */
  rightsDetail?: TextConstruct
  /** Generator name */
  generator?: string
  /** Detailed generator information */
  generatorDetail?: Generator
  /** Feed image */
  image?: Image
  /** Icon URL (small image) */
  icon?: string
  /** Logo URL (larger image) */
  logo?: string
  /** Feed-level tags/categories */
  tags: Array<Tag>
  /** Unique feed identifier */
  id?: string
  /** Time-to-live (update frequency hint) in minutes */
  ttl?: number
  /** License URL (Creative Commons, etc.) */
  license?: string
  /** Syndication module metadata (RSS 1.0) */
  syndication?: SyndicationMeta
  /** Dublin Core creator (author fallback) */
  dcCreator?: string
  /** Dublin Core publisher */
  dcPublisher?: string
  /** Dublin Core rights (copyright) */
  dcRights?: string
  /** Geographic location (GeoRSS) */
  geo?: GeoLocation
  /** iTunes podcast metadata */
  itunes?: ItunesFeedMeta
  /** Podcast 2.0 metadata */
  podcast?: PodcastMeta
}

/** Generator metadata */
export interface Generator {
  /** Generator name */
  value: string
  /** Generator URI */
  uri?: string
  /** Generator version */
  version?: string
}

/** Geographic location from GeoRSS namespace */
export interface GeoLocation {
  /** Type of geographic shape ("point", "line", "polygon", "box") */
  geoType: string
  /**
   * Coordinate pairs as nested array [[lat, lng], ...]
   *
   * Format depends on geo_type:
   * - "point": Single pair [[lat, lng]]
   * - "line": Two or more pairs [[lat1, lng1], [lat2, lng2], ...]
   * - "box": Two pairs [[lower-left-lat, lower-left-lng], [upper-right-lat, upper-right-lng]]
   * - "polygon": Three or more pairs forming a closed shape [[lat1, lng1], ..., [lat1, lng1]]
   */
  coordinates: Array<Array<number>>
  /** Coordinate Reference System (e.g., "EPSG:4326" for WGS84 latitude/longitude) */
  crs?: string
}

/** Image metadata */
export interface Image {
  /** Image URL */
  url: string
  /** Image title */
  title?: string
  /** Link associated with the image */
  link?: string
  /** Image width in pixels */
  width?: number
  /** Image height in pixels */
  height?: number
  /** Image description */
  description?: string
}

/** iTunes category */
export interface ItunesCategory {
  /** Category text */
  text: string
  /** Subcategory */
  subcategory?: string
}

/** iTunes episode metadata */
export interface ItunesEntryMeta {
  /** Episode title override */
  title?: string
  /** Episode author */
  author?: string
  /**
   * Episode duration in seconds
   *
   * Parsed from various formats: "3600", "60:00", "1:00:00"
   */
  duration?: number
  /** Explicit content flag for this episode */
  explicit?: boolean
  /**
   * Episode-specific artwork URL
   *
   * Note: URL from untrusted feed input. Validate before fetching.
   */
  image?: string
  /** Episode number */
  episode?: number
  /** Season number */
  season?: number
  /** Episode type: "full", "trailer", or "bonus" */
  episodeType?: string
}

/** iTunes podcast feed metadata */
export interface ItunesFeedMeta {
  /** Podcast author */
  author?: string
  /** Podcast owner information */
  owner?: ItunesOwner
  /** Podcast categories */
  categories: Array<ItunesCategory>
  /** Explicit content flag */
  explicit?: boolean
  /**
   * Podcast artwork URL
   *
   * Note: URL from untrusted feed input. Validate before fetching.
   */
  image?: string
  /** Podcast keywords */
  keywords: Array<string>
  /** Podcast type (episodic/serial) */
  podcastType?: string
  /** Podcast completion status */
  complete?: boolean
  /**
   * New feed URL for migrated podcasts
   *
   * Note: URL from untrusted feed input. Validate before fetching.
   */
  newFeedUrl?: string
}

/** iTunes owner information */
export interface ItunesOwner {
  /** Owner name */
  name?: string
  /** Owner email */
  email?: string
}

/** Link in feed or entry */
export interface Link {
  /** Link URL */
  href: string
  /** Link relationship type (e.g., "alternate", "enclosure", "self") */
  rel?: string
  /** MIME type of the linked resource */
  type?: string
  /** Human-readable link title */
  title?: string
  /** Length of the linked resource in bytes */
  length?: number
  /** Language of the linked resource */
  hreflang?: string
}

/** Media RSS content */
export interface MediaContent {
  /**
   * Media URL
   *
   * Note: URL from untrusted feed input. Validate before fetching.
   */
  url: string
  /** MIME type */
  type?: string
  /** File size in bytes (converted from u64 with i64::MAX cap) */
  filesize?: number
  /** Width in pixels */
  width?: number
  /** Height in pixels */
  height?: number
  /** Duration in seconds (converted from u64 with i64::MAX cap) */
  duration?: number
}

/** Media RSS thumbnail */
export interface MediaThumbnail {
  /**
   * Thumbnail URL
   *
   * Note: URL from untrusted feed input. Validate before fetching.
   */
  url: string
  /** Width in pixels */
  width?: number
  /** Height in pixels */
  height?: number
}

/**
 * Parse an RSS/Atom/JSON Feed from bytes or string
 *
 * # Arguments
 *
 * * `source` - Feed content as Buffer, string, or Uint8Array
 *
 * # Returns
 *
 * Parsed feed result with metadata and entries
 *
 * # Errors
 *
 * Returns error if input exceeds size limit or parsing fails catastrophically
 */
export declare function parse(source: Buffer | string): ParsedFeed

/**
 * Parsed feed result
 *
 * This is analogous to Python feedparser's `FeedParserDict`.
 */
export interface ParsedFeed {
  /** Feed metadata */
  feed: FeedMeta
  /** Feed entries/items */
  entries: Array<Entry>
  /** True if parsing encountered errors */
  bozo: boolean
  /** Description of parsing error (if bozo is true) */
  bozoException?: string
  /** Detected or declared encoding */
  encoding: string
  /** Detected feed format version */
  version: string
  /** XML namespaces (prefix -> URI) */
  namespaces: Record<string, string>
  /** HTTP status code (if fetched from URL) */
  status?: number
  /** Final URL after redirects (if fetched from URL) */
  href?: string
  /** ETag header from HTTP response */
  etag?: string
  /** Last-Modified header from HTTP response */
  modified?: string
  /** HTTP response headers (if fetched from URL) */
  headers?: Record<string, string>
}

/**
 * Parse feed from HTTP/HTTPS URL with conditional GET support
 *
 * Fetches the feed from the given URL and parses it. Supports conditional GET
 * using ETag and Last-Modified headers for bandwidth-efficient caching.
 *
 * # Arguments
 *
 * * `url` - HTTP or HTTPS URL to fetch
 * * `etag` - Optional ETag from previous fetch for conditional GET
 * * `modified` - Optional Last-Modified timestamp from previous fetch
 * * `user_agent` - Optional custom User-Agent header
 *
 * # Returns
 *
 * Parsed feed result with HTTP metadata fields populated:
 * - `status`: HTTP status code (200, 304, etc.)
 * - `href`: Final URL after redirects
 * - `etag`: ETag header value (for next request)
 * - `modified`: Last-Modified header value (for next request)
 * - `headers`: Full HTTP response headers
 *
 * On 304 Not Modified, returns a feed with empty entries but status=304.
 *
 * # Examples
 *
 * ```javascript
 * const feedparser = require('feedparser-rs');
 *
 * // First fetch
 * const feed = await feedparser.parseUrl("https://example.com/feed.xml");
 * console.log(feed.feed.title);
 * console.log(`ETag: ${feed.etag}`);
 *
 * // Subsequent fetch with caching
 * const feed2 = await feedparser.parseUrl(
 *   "https://example.com/feed.xml",
 *   feed.etag,
 *   feed.modified
 * );
 *
 * if (feed2.status === 304) {
 *   console.log("Feed not modified, use cached version");
 * }
 * ```
 */
export declare function parseUrl(url: string, etag?: string | undefined | null, modified?: string | undefined | null, userAgent?: string | undefined | null): ParsedFeed

/**
 * Parse feed from URL with custom resource limits
 *
 * Like `parseUrl` but allows specifying custom limits for DoS protection.
 *
 * # Examples
 *
 * ```javascript
 * const feedparser = require('feedparser-rs');
 *
 * const feed = await feedparser.parseUrlWithOptions(
 *   "https://example.com/feed.xml",
 *   null, // etag
 *   null, // modified
 *   null, // user_agent
 *   10485760 // max_size: 10MB
 * );
 * ```
 */
export declare function parseUrlWithOptions(url: string, etag?: string | undefined | null, modified?: string | undefined | null, userAgent?: string | undefined | null, maxSize?: number | undefined | null): ParsedFeed

/**
 * Parse an RSS/Atom/JSON Feed with custom size limit
 *
 * # Arguments
 *
 * * `source` - Feed content as Buffer, string, or Uint8Array
 * * `max_size` - Optional maximum feed size in bytes (default: 100MB)
 *
 * # Returns
 *
 * Parsed feed result with metadata and entries
 *
 * # Errors
 *
 * Returns error if input exceeds size limit or parsing fails catastrophically
 */
export declare function parseWithOptions(source: Buffer | string, maxSize?: number | undefined | null): ParsedFeed

/** Person (author, contributor, etc.) */
export interface Person {
  /** Person's name */
  name?: string
  /** Person's email address */
  email?: string
  /** Person's URI/website */
  uri?: string
}

/** Podcast chapters */
export interface PodcastChapters {
  /**
   * Chapters URL
   *
   * Note: URL from untrusted feed input. Validate before fetching.
   */
  url: string
  /** Chapters MIME type (e.g., "application/json+chapters", "application/xml+chapters") */
  type: string
}

/** Podcast 2.0 episode metadata */
export interface PodcastEntryMeta {
  /** Episode transcripts */
  transcript: Array<PodcastTranscript>
  /** Episode chapters */
  chapters?: PodcastChapters
  /** Episode soundbites */
  soundbite: Array<PodcastSoundbite>
  /** Episode persons */
  person: Array<PodcastPerson>
}

/** Podcast funding link */
export interface PodcastFunding {
  /**
   * Funding URL
   *
   * Note: URL from untrusted feed input. Validate before fetching.
   */
  url: string
  /** Funding message */
  message?: string
}

/** Podcast 2.0 namespace metadata (feed level) */
export interface PodcastMeta {
  /** Podcast transcripts */
  transcripts: Array<PodcastTranscript>
  /** Podcast funding links */
  funding: Array<PodcastFunding>
  /** Podcast persons (hosts, etc.) */
  persons: Array<PodcastPerson>
  /** Podcast GUID */
  guid?: string
  /** Value-for-value payment information */
  value?: PodcastValue
}

/** Podcast person metadata */
export interface PodcastPerson {
  /** Person's name */
  name: string
  /** Person's role (e.g., "host", "guest") */
  role?: string
  /** Person's group (e.g., "cast", "crew") */
  group?: string
  /**
   * Person's image URL
   *
   * Note: URL from untrusted feed input. Validate before fetching.
   */
  img?: string
  /**
   * Person's URL/website
   *
   * Note: URL from untrusted feed input. Validate before fetching.
   */
  href?: string
}

/** Podcast soundbite */
export interface PodcastSoundbite {
  /** Start time in seconds */
  startTime: number
  /** Duration in seconds */
  duration: number
  /** Title */
  title?: string
}

/** Podcast transcript metadata */
export interface PodcastTranscript {
  /**
   * Transcript URL
   *
   * Note: URL from untrusted feed input. Validate before fetching.
   */
  url: string
  /** Transcript type (e.g., "text/plain", "application/srt") */
  type?: string
  /** Transcript language */
  language?: string
  /** Relationship type (e.g., "captions", "chapters") */
  rel?: string
}

/** Podcast 2.0 value element for monetization */
export interface PodcastValue {
  /** Payment type: "lightning", "hive", etc. */
  type: string
  /** Payment method: "keysend" for Lightning Network */
  method: string
  /** Suggested payment amount */
  suggested?: string
  /** List of payment recipients with split percentages */
  recipients: Array<PodcastValueRecipient>
}

/** Value recipient for payment splitting */
export interface PodcastValueRecipient {
  /** Recipient's name */
  name?: string
  /** Recipient type: "node" for Lightning Network nodes */
  type: string
  /** Payment address (e.g., Lightning node public key) */
  address: string
  /** Payment split percentage */
  split: number
  /** Whether this is a fee recipient */
  fee?: boolean
}

/** Source reference (for entries) */
export interface Source {
  /** Source title */
  title?: string
  /** Source link */
  link?: string
  /** Source ID */
  id?: string
}

/** Syndication module metadata (RSS 1.0) */
export interface SyndicationMeta {
  /**
   * Update period (hourly, daily, weekly, monthly, yearly)
   *
   * # Example
   *
   * "daily" with updateFrequency: 2 means the feed updates twice per day
   */
  updatePeriod?: string
  /** Number of times updated per period */
  updateFrequency?: number
  /** Base date for update schedule (ISO 8601) */
  updateBase?: string
}

/** Tag/category */
export interface Tag {
  /** Tag term/label */
  term: string
  /** Tag scheme/domain */
  scheme?: string
  /** Human-readable tag label */
  label?: string
}

/** Text construct with metadata */
export interface TextConstruct {
  /** Text content */
  value: string
  /** Content type ("text", "html", "xhtml") */
  type: string
  /** Content language */
  language?: string
  /** Base URL for relative links */
  base?: string
}
