/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Content block */
export interface Content {
  /** Content body */
  value: string
  /** Content MIME type */
  type?: string
  /** Content language */
  language?: string
  /** Base URL for relative links */
  base?: string
}

/**
 * Detect feed format without full parsing
 *
 * # Arguments
 *
 * * `source` - Feed content as Buffer, string, or Uint8Array
 *
 * # Returns
 *
 * Feed version string (e.g., "rss20", "atom10")
 */
export declare function detectFormat(source: Buffer | string): string

/** Enclosure (attached media file) */
export interface Enclosure {
  /** Enclosure URL */
  url: string
  /** File size in bytes */
  length?: number
  /** MIME type */
  type?: string
}

/** Feed entry/item */
export interface Entry {
  /** Unique entry identifier */
  id?: string
  /** Entry title */
  title?: string
  /** Detailed title with metadata */
  titleDetail?: TextConstruct
  /** Primary link */
  link?: string
  /** All links associated with this entry */
  links: Array<Link>
  /** Short description/summary */
  summary?: string
  /** Detailed summary with metadata */
  summaryDetail?: TextConstruct
  /** Full content blocks */
  content: Array<Content>
  /** Publication date (milliseconds since epoch) */
  published?: number
  /** Last update date (milliseconds since epoch) */
  updated?: number
  /** Creation date (milliseconds since epoch) */
  created?: number
  /** Expiration date (milliseconds since epoch) */
  expired?: number
  /** Primary author name */
  author?: string
  /** Detailed author information */
  authorDetail?: Person
  /** All authors */
  authors: Array<Person>
  /** Contributors */
  contributors: Array<Person>
  /** Publisher name */
  publisher?: string
  /** Detailed publisher information */
  publisherDetail?: Person
  /** Tags/categories */
  tags: Array<Tag>
  /** Media enclosures (audio, video, etc.) */
  enclosures: Array<Enclosure>
  /** Comments URL or text */
  comments?: string
  /** Source feed reference */
  source?: Source
  /** Podcast transcripts */
  podcastTranscripts: Array<PodcastTranscript>
  /** Podcast persons */
  podcastPersons: Array<PodcastPerson>
  /** License URL (Creative Commons, etc.) */
  license?: string
}

/** Feed metadata */
export interface FeedMeta {
  /** Feed title */
  title?: string
  /** Detailed title with metadata */
  titleDetail?: TextConstruct
  /** Primary feed link */
  link?: string
  /** All links associated with this feed */
  links: Array<Link>
  /** Feed subtitle/description */
  subtitle?: string
  /** Detailed subtitle with metadata */
  subtitleDetail?: TextConstruct
  /** Last update date (milliseconds since epoch) */
  updated?: number
  /** Initial publication date (milliseconds since epoch) */
  published?: number
  /** Primary author name */
  author?: string
  /** Detailed author information */
  authorDetail?: Person
  /** All authors */
  authors: Array<Person>
  /** Contributors */
  contributors: Array<Person>
  /** Publisher name */
  publisher?: string
  /** Detailed publisher information */
  publisherDetail?: Person
  /** Feed language (e.g., "en-us") */
  language?: string
  /** Copyright/rights statement */
  rights?: string
  /** Detailed rights with metadata */
  rightsDetail?: TextConstruct
  /** Generator name */
  generator?: string
  /** Detailed generator information */
  generatorDetail?: Generator
  /** Feed image */
  image?: Image
  /** Icon URL (small image) */
  icon?: string
  /** Logo URL (larger image) */
  logo?: string
  /** Feed-level tags/categories */
  tags: Array<Tag>
  /** Unique feed identifier */
  id?: string
  /** Time-to-live (update frequency hint) in minutes */
  ttl?: number
  /** License URL (Creative Commons, etc.) */
  license?: string
  /** Syndication module metadata (RSS 1.0) */
  syndication?: SyndicationMeta
  /** Dublin Core creator (author fallback) */
  dcCreator?: string
  /** Dublin Core publisher */
  dcPublisher?: string
  /** Dublin Core rights (copyright) */
  dcRights?: string
}

/** Generator metadata */
export interface Generator {
  /** Generator name */
  value: string
  /** Generator URI */
  uri?: string
  /** Generator version */
  version?: string
}

/** Image metadata */
export interface Image {
  /** Image URL */
  url: string
  /** Image title */
  title?: string
  /** Link associated with the image */
  link?: string
  /** Image width in pixels */
  width?: number
  /** Image height in pixels */
  height?: number
  /** Image description */
  description?: string
}

/** Link in feed or entry */
export interface Link {
  /** Link URL */
  href: string
  /** Link relationship type (e.g., "alternate", "enclosure", "self") */
  rel?: string
  /** MIME type of the linked resource */
  type?: string
  /** Human-readable link title */
  title?: string
  /** Length of the linked resource in bytes */
  length?: number
  /** Language of the linked resource */
  hreflang?: string
}

/**
 * Parse an RSS/Atom/JSON Feed from bytes or string
 *
 * # Arguments
 *
 * * `source` - Feed content as Buffer, string, or Uint8Array
 *
 * # Returns
 *
 * Parsed feed result with metadata and entries
 *
 * # Errors
 *
 * Returns error if input exceeds size limit or parsing fails catastrophically
 */
export declare function parse(source: Buffer | string): ParsedFeed

/**
 * Parsed feed result
 *
 * This is analogous to Python feedparser's `FeedParserDict`.
 */
export interface ParsedFeed {
  /** Feed metadata */
  feed: FeedMeta
  /** Feed entries/items */
  entries: Array<Entry>
  /** True if parsing encountered errors */
  bozo: boolean
  /** Description of parsing error (if bozo is true) */
  bozoException?: string
  /** Detected or declared encoding */
  encoding: string
  /** Detected feed format version */
  version: string
  /** XML namespaces (prefix -> URI) */
  namespaces: Record<string, string>
  /** HTTP status code (if fetched from URL) */
  status?: number
  /** Final URL after redirects (if fetched from URL) */
  href?: string
  /** ETag header from HTTP response */
  etag?: string
  /** Last-Modified header from HTTP response */
  modified?: string
  /** HTTP response headers (if fetched from URL) */
  headers?: Record<string, string>
}

/**
 * Parse feed from HTTP/HTTPS URL with conditional GET support
 *
 * Fetches the feed from the given URL and parses it. Supports conditional GET
 * using ETag and Last-Modified headers for bandwidth-efficient caching.
 *
 * # Arguments
 *
 * * `url` - HTTP or HTTPS URL to fetch
 * * `etag` - Optional ETag from previous fetch for conditional GET
 * * `modified` - Optional Last-Modified timestamp from previous fetch
 * * `user_agent` - Optional custom User-Agent header
 *
 * # Returns
 *
 * Parsed feed result with HTTP metadata fields populated:
 * - `status`: HTTP status code (200, 304, etc.)
 * - `href`: Final URL after redirects
 * - `etag`: ETag header value (for next request)
 * - `modified`: Last-Modified header value (for next request)
 * - `headers`: Full HTTP response headers
 *
 * On 304 Not Modified, returns a feed with empty entries but status=304.
 *
 * # Examples
 *
 * ```javascript
 * const feedparser = require('feedparser-rs');
 *
 * // First fetch
 * const feed = await feedparser.parseUrl("https://example.com/feed.xml");
 * console.log(feed.feed.title);
 * console.log(`ETag: ${feed.etag}`);
 *
 * // Subsequent fetch with caching
 * const feed2 = await feedparser.parseUrl(
 *   "https://example.com/feed.xml",
 *   feed.etag,
 *   feed.modified
 * );
 *
 * if (feed2.status === 304) {
 *   console.log("Feed not modified, use cached version");
 * }
 * ```
 */
export declare function parseUrl(url: string, etag?: string | undefined | null, modified?: string | undefined | null, userAgent?: string | undefined | null): ParsedFeed

/**
 * Parse feed from URL with custom resource limits
 *
 * Like `parseUrl` but allows specifying custom limits for DoS protection.
 *
 * # Examples
 *
 * ```javascript
 * const feedparser = require('feedparser-rs');
 *
 * const feed = await feedparser.parseUrlWithOptions(
 *   "https://example.com/feed.xml",
 *   null, // etag
 *   null, // modified
 *   null, // user_agent
 *   10485760 // max_size: 10MB
 * );
 * ```
 */
export declare function parseUrlWithOptions(url: string, etag?: string | undefined | null, modified?: string | undefined | null, userAgent?: string | undefined | null, maxSize?: number | undefined | null): ParsedFeed

/**
 * Parse an RSS/Atom/JSON Feed with custom size limit
 *
 * # Arguments
 *
 * * `source` - Feed content as Buffer, string, or Uint8Array
 * * `max_size` - Optional maximum feed size in bytes (default: 100MB)
 *
 * # Returns
 *
 * Parsed feed result with metadata and entries
 *
 * # Errors
 *
 * Returns error if input exceeds size limit or parsing fails catastrophically
 */
export declare function parseWithOptions(source: Buffer | string, maxSize?: number | undefined | null): ParsedFeed

/** Person (author, contributor, etc.) */
export interface Person {
  /** Person's name */
  name?: string
  /** Person's email address */
  email?: string
  /** Person's URI/website */
  uri?: string
}

/** Podcast person metadata */
export interface PodcastPerson {
  /** Person's name */
  name: string
  /** Person's role (e.g., "host", "guest") */
  role?: string
  /** Person's group (e.g., "cast", "crew") */
  group?: string
  /** Person's image URL */
  img?: string
  /** Person's URL/website */
  href?: string
}

/** Podcast transcript metadata */
export interface PodcastTranscript {
  /** Transcript URL */
  url: string
  /** Transcript type (e.g., "text/plain", "application/srt") */
  type?: string
  /** Transcript language */
  language?: string
  /** Relationship type (e.g., "captions", "chapters") */
  rel?: string
}

/** Source reference (for entries) */
export interface Source {
  /** Source title */
  title?: string
  /** Source link */
  link?: string
  /** Source ID */
  id?: string
}

/** Syndication module metadata (RSS 1.0) */
export interface SyndicationMeta {
  /** Update period (hourly, daily, weekly, monthly, yearly) */
  updatePeriod?: string
  /** Number of times updated per period */
  updateFrequency?: number
  /** Base date for update schedule (ISO 8601) */
  updateBase?: string
}

/** Tag/category */
export interface Tag {
  /** Tag term/label */
  term: string
  /** Tag scheme/domain */
  scheme?: string
  /** Human-readable tag label */
  label?: string
}

/** Text construct with metadata */
export interface TextConstruct {
  /** Text content */
  value: string
  /** Content type ("text", "html", "xhtml") */
  type: string
  /** Content language */
  language?: string
  /** Base URL for relative links */
  base?: string
}
